/*
==============================================
Typescript definitions for v1.0
==============================================

This file was automatically generated by Papyrus-2-Typescript.exe
https://github.com/CarlosLeyvaAyala/Papyrus-2-Typescript

The program has no way to know the intention of the humans that made
the scripts, so it's always advisable to manually check all generated
files to make sure everything is declared as it should.

Take note the program assumes this script exists in some subfolder
to the folder where `skyrimPlatform.ts` is found, otherwise you'll get
"Cannot find module..." type of errors.

If you want to have this script in some other place, just change the
relative path of each `import`.
*/
const sn = (sp as any).TestScript

/** ----------------------------------------------------------------------------------------------------------
* COMMENT
* ----------------------------------------------------------------------------------------------------------
*/

export const BoolFunc = (akActiveEffect: ActiveMagicEffect | null, asScriptName: string): boolean => sn.BoolFunc(akActiveEffect, asScriptName)

/** Returns an array of all the existing key'd transforms to the particular node
* NodeDestination is a special key
*/
export const GetNodeTransformKeys = (akRef: ObjectReference | null, firstPerson: boolean, isFemale: boolean, nodeName: string): string[] => sn.GetNodeTransformKeys(akRef, firstPerson, isFemale, nodeName)
// --------------------------------------------------------------------
    
export const ArrayFunc = (akActor: Actor | null, abShowInactive: boolean = false): (MagicEffect | null)[] => sn.ArrayFunc(akActor, abShowInactive)
	
export const ArrayToArrayFunc = (akActor: (Actor | null)[]): (Form | null)[] => sn.ArrayToArrayFunc(akActor)
	
export const BiArrayFunc = (akActor: (Actor | null)[][]): number => sn.BiArrayFunc(akActor)
export const DefaultFunc = (akActor: Form | null = null): void => sn.DefaultFunc(akActor)
/** This is a block comment
*/
/** This 
* is a 
* 	block comment
*/
// THis is a comment }
		// Event OnNewEvent(Actor akMeh, Actor akMoh)
		// EndEvent
	
/** Copy all items to new native Papyrus array of dynamic size.
*     Items not matching the requested type will have default
*     values as the ones from the getInt/Flt/Str/Form functions.
*/
export const asIntArray = (object: number): number[] => sn.asIntArray(object)

/** Override packages of actors.
* 
* 	These overrides persist through save games. If you override package on same actor
* 	more than once then the package with highest priority will run, if multiple
* 	overrides have same priority then last added package will run. Priority ranges
* 	from 0 to 100 with 100 being highest priority.
*/

/** This will add a package to actor that will override its normal behavior. Using this function overrides all packages added from any other location. */
export const AddPackageOverride = (targetActor: Actor | null, targetPackage: Package | null, priority: number = 30, flags: number = 0): void => sn.AddPackageOverride(targetActor, targetPackage, priority, flags)

/** Remove a previously added package override. */
export const RemovePackageOverride = (targetActor: Actor | null, targetPackage: Package | null): boolean => sn.RemovePackageOverride(targetActor, targetPackage)

/** Check if a json file exists or not */
export const JsonExists = (FileName: string): boolean => sn.JsonExists(FileName)
	if !FileName
		return false
	elseIf StringUtil.Find(FileName, ".json") == -1
		FileName += ".json"
	endIf
	return MiscUtil.FileExists("data/skse/plugins/StorageUtilData/"+FileName)
endFunction

/** Simplifies iteration over container's contents.
*     Accepts the @previousKey, returns the next key.
*     If @previousKey == @endKey the function returns the first key.
*     The function always returns so-called 'valid' keys (the ones != @endKey).
*     The function returns @endKey ('invalid' key) only once to signal that iteration has reached its end.
*     In most cases, if the map doesn't contain an invalid key ("" for JMap, None form-key for JFormMap)
*     it's ok to omit the @endKey.
*     
*     Usage:
*     
*         string key = JMap.nextKey(map, previousKey="", endKey="")
*         while key != ""
*           <retrieve values here>
*           key = JMap.nextKey(map, key, endKey="")
*         endwhile
*/
export const nextKey = (object: number, previousKey: Form | null = null, endKey: Form | null = null): Form | null => sn.nextKey(object, previousKey, endKey)

/** Attempts to retrieve the value associated with the @path.
*     For ex. the following information associated with 'frosfall' key:
*     
*     "frostfall" : {
*         "exposureRate" : 0.5,
*         "arrayC" : ["stringValue", 1.5, 10, 1.14]
*     }
*     
*     then JDB.solveFlt(".frostfall.exposureRate") will return 0.5 and
*     JDB.solveObj(".frostfall.arrayC") will return the array containing ["stringValue", 1.5, 10, 1.14] values
*/
export const solveFlt = (path: string, defaultVal: number = 0.0): number => sn.solveFlt(path, defaultVal)

/** Get version of papyrus DLL library. Version 4.1 will return 41. */
export const GetVersion = (): number => sn.GetVersion()

/** Get version of compiled papyrus scripts which should match return from GetVersion() */
export const GetScriptVersion = (): number => sn.GetScriptVersion()
	return 43
endFunction

/** ##
* ## Array manipulation utilities
* ##
* ## Similar to the clamp functions, only values wrap around to the other side of range instead.
* ## Mostly useful for traversing around array values by wrapping the index from end to end without having to check for it being out of range first.
* ##     i.e.: Form var = myFormArray[WrapInt(i, (myFormArray.Length - 1))]
*/
export const WrapInt = (value: number, end: number, start: number = 0): number => sn.WrapInt(value, end, start)
export const WrapFloat = (value: number, end: number, start: number = 0.0): number => sn.WrapFloat(value, end, start)

/** ## Returns the given value signed if bool is true, unsigned if false, regardless if value started out signed or not.  */
export const SignInt = (doSign: boolean, value: number): number => sn.SignInt(doSign, value)
export const SignFloat = (doSign: boolean, value: number): number => sn.SignFloat(doSign, value)

/** ##
* ## Non-Native bool versions of some functions where SKSE version is bugged.
* ## SKSE version VMResultArray<bool> fails to be manipulated by other native functions past creation.
* ##
*/

export const ResizeBoolArray = (ArrayValues: boolean[], toSize: number, filler: boolean = false): boolean[] => sn.ResizeBoolArray(ArrayValues, toSize, filler)
	bool[] Output = Utility.CreateBoolArray(toSize, filler)
	int i = ArrayValues.Length
	if i > toSize
		i = toSize
	endIf
	while i
		i -= 1
		Output[i] = ArrayValues[i]
	endWhile
	return Output
endFunction

export const PushBool = (ArrayValues: boolean[], push: boolean): boolean[] => sn.PushBool(ArrayValues, push)
	return ResizeBoolArray(ArrayValues, ArrayValues.Length + 1, push)
endFunction

export const RemoveBool = (ArrayValues: boolean[], ToRemove: boolean): boolean[] => sn.RemoveBool(ArrayValues, ToRemove)
	int count = CountBool(ArrayValues, ToRemove)
	return Utility.CreateBoolArray((ArrayValues.Length - Count), !ToRemove)
endFunction

export const MergeBoolArray = (ArrayValues1: boolean[], ArrayValues2: boolean[], RemoveDupes: boolean = false): boolean[] => sn.MergeBoolArray(ArrayValues1, ArrayValues2, RemoveDupes)
	if !ArrayValues1 && !ArrayValues2
		return Utility.CreateBoolArray(0)
	elseIf RemoveDupes
		// Don't know why this option would ever be used for bool arrays, but provided for consistency sake with others
		bool[] Output = new bool[1]
		Output[0] = (ArrayValues1 && ArrayValues1[0]) || (!ArrayValues1 && ArrayValues2 && ArrayValues2[0])
		if (ArrayValues1 && ArrayValues1.Find(!Output[0]) != -1) || (ArrayValues2 && ArrayValues2.Find(!Output[0]) != -1)
			Output = PushBool(Output, !Output[0])
		endIf
		return Output
	elseIf !ArrayValues1
		return ArrayValues2
	elseIf !ArrayValues2
		return ArrayValues1
	endIf
	bool[] Output = Utility.CreateBoolArray(ArrayValues1.Length + ArrayValues2.Length)
	bool[] Source = ArrayValues2
	int n = Source.Length
	int i = Output.Length
	while i
		i -= 1
		n -= 1
		if n < 0 && i > 0
			Source = ArrayValues1
			n = ArrayValues1.Length - 1
		endIf
		Output[i] = Source[n]
	endWhile
	return Output
endFunction

export const SliceBoolArray = (ArrayValues: boolean[], StartIndex: number, EndIndex: number = -1): boolean[] => sn.SliceBoolArray(ArrayValues, StartIndex, EndIndex)
	if !ArrayValues || (StartIndex > EndIndex && EndIndex > -1)
		return Utility.CreateBoolArray(0)
	elseIf StartIndex <= 0 && (EndIndex == -1 || EndIndex >= ArrayValues.Length)
		return ArrayValues
	endIf
	if StartIndex < 0
		StartIndex = 0
	endIf
	if EndIndex < 0 || EndIndex >= ArrayValues.Length
		EndIndex = ArrayValues.Length - 1
	endIf
	if StartIndex == EndIndex
		return Utility.CreateBoolArray(1, ArrayValues[StartIndex])
	endIf
	EndIndex += 1
	bool[] Output = Utility.CreateBoolArray(EndIndex - StartIndex)
	int i = Output.Length
	while i && EndIndex
		i -= 1
		EndIndex -= 1
		Output[i] = ArrayValues[EndIndex]
	endWhile
	return Output
endFunction

/** ##
* ## DEPRECATED: SKSE now provides their own variable sized arrays for these types - mirrored here for backwards compatibility.
* ##
*/

export const FloatArray = (size: number, filler: number = 0.0): number[] => sn.FloatArray(size, filler)
	return Utility.CreateFloatArray(size, filler)
endFunction
export const IntArray = (size: number, filler: number = 0): number[] => sn.IntArray(size, filler)
	return Utility.CreateIntArray(size, filler)
endFunction
export const BoolArray = (size: number, filler: boolean = false): boolean[] => sn.BoolArray(size, filler)
	return Utility.CreateBoolArray(size, filler)
endFunction
export const StringArray = (size: number, filler: string = ""): string[] => sn.StringArray(size, filler)
	return Utility.CreateStringArray(size, filler)
endFunction
export const FormArray = (size: number, filler: Form | null = null): (Form | null)[] => sn.FormArray(size, filler)
	return Utility.CreateFormArray(size, filler)
endFunction
export const AliasArray = (size: number, filler: Alias | null = null): (Alias | null)[] => sn.AliasArray(size, filler)
	return Utility.CreateAliasArray(size, filler)
endFunction

export const ResizeFloatArray = (ArrayValues: number[], toSize: number, filler: number = 0.0): number[] => sn.ResizeFloatArray(ArrayValues, toSize, filler)
	return Utility.ResizeFloatArray(ArrayValues, toSize, filler)
endFunction
export const ResizeIntArray = (ArrayValues: number[], toSize: number, filler: number = 0): number[] => sn.ResizeIntArray(ArrayValues, toSize, filler)
	return Utility.ResizeIntArray(ArrayValues, toSize, filler)
endFunction
export const ResizeStringArray = (ArrayValues: string[], toSize: number, filler: string = ""): string[] => sn.ResizeStringArray(ArrayValues, toSize, filler)
	return Utility.ResizeStringArray(ArrayValues, toSize, filler)
endFunction
export const ResizeFormArray = (ArrayValues: (Form | null)[], toSize: number, filler: Form | null = null): (Form | null)[] => sn.ResizeFormArray(ArrayValues, toSize, filler)
	return Utility.ResizeFormArray(ArrayValues, toSize, filler)
endFunction
export const ResizeAliasArray = (ArrayValues: (Alias | null)[], toSize: number, filler: Alias | null = null): (Alias | null)[] => sn.ResizeAliasArray(ArrayValues, toSize, filler)
	return Utility.ResizeAliasArray(ArrayValues, toSize, filler)
endFunction