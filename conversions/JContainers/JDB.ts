/*
This file was automatically generated by Papyrus-2-Typescript.exe
https://github.com/CarlosLeyvaAyala/Papyrus-2-Typescript

The program has no way to know the intention of the humans that made
the scripts, so it's always advisable to manually check all generated
files to make sure everything is declared as it should.

Take note the program assumes this script exists in some subfolder
to the folder where `skyrimPlatform.ts` is found, otherwise you'll get
"Cannot find module..." type of errors.

If you want to have this script in some other place, just change the
relative path of each `import`.
*/

import * as sp from "../skyrimPlatform"
import { Form } from "../skyrimPlatform"

/** Global entry point to store mod information. Main intent - replace global variables
    Manages keys and values associations (like JMap) */
const sn = (sp as any).JDB

/** Attempts to retrieve the value associated with the @path.
    For ex. the following information associated with 'frosfall' key:
    
    "frostfall" : {
        "exposureRate" : 0.5,
        "arrayC" : ["stringValue", 1.5, 10, 1.14]
    }
    
    then JDB.solveFlt(".frostfall.exposureRate") will return 0.5 and
    JDB.solveObj(".frostfall.arrayC") will return the array containing ["stringValue", 1.5, 10, 1.14] values */
export const solveFlt = (path: string, defaultVal: number = 0.0): number => sn.solveFlt(path,  defaultVal)
export const solveInt = (path: string, defaultVal: number = 0): number => sn.solveInt(path,  defaultVal)
export const solveStr = (path: string, defaultVal: string = ""): string => sn.solveStr(path,  defaultVal)
export const solveObj = (path: string, defaultVal: number = 0): number => sn.solveObj(path,  defaultVal)
export const solveForm = (path: string, defaultVal: Form | null | undefined = null): Form | null | undefined => sn.solveForm(path,  defaultVal)

/** Attempts to assign the @value. Returns false if no such path.
    If 'createMissingKeys=true' it creates any missing path elements: JDB.solveIntSetter(".frostfall.keyB", 10, true) creates {frostfall: {keyB: 10}} structure */
export const solveFltSetter = (path: string, value: number, createMissingKeys: boolean = false): boolean => sn.solveFltSetter(path,  value,  createMissingKeys)
export const solveIntSetter = (path: string, value: number, createMissingKeys: boolean = false): boolean => sn.solveIntSetter(path,  value,  createMissingKeys)
export const solveStrSetter = (path: string, value: string, createMissingKeys: boolean = false): boolean => sn.solveStrSetter(path,  value,  createMissingKeys)
export const solveObjSetter = (path: string, value: number, createMissingKeys: boolean = false): boolean => sn.solveObjSetter(path,  value,  createMissingKeys)
export const solveFormSetter = (path: string, value: Form | null | undefined, createMissingKeys: boolean = false): boolean => sn.solveFormSetter(path,  value,  createMissingKeys)

/** Associates(and replaces previous association) container object with a string key.
    destroys association if object is zero
    for ex. JDB.setObj("frostfall", frostFallInformation) will associate 'frostall' key and frostFallInformation so you can access it later */
export const setObj = (key: string, object: number): void => sn.setObj(key,  object)

/** Returns true, if JDB capable resolve given @path, i.e. if it able to execute solve* or solver*Setter functions successfully */
export const hasPath = (path: string): boolean => sn.hasPath(path)

/** returns new array containing all JDB keys */
export const allKeys = (): number => sn.allKeys()

/** returns new array containing all containers associated with JDB */
export const allValues = (): number => sn.allValues()

/** writes storage data into JSON file at given path */
export const writeToFile = (path: string): void => sn.writeToFile(path)

/** Returns underlying JDB's container - an instance of JMap.
    The object being owned (retained) internally, so you don't have to (but can) retain or release it. */
export const root = (): number => sn.root()
