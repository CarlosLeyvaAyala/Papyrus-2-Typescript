/*
This file was automatically generated by Papyrus-2-Typescript.exe
https://github.com/CarlosLeyvaAyala/Papyrus-2-Typescript

The program has no way to know the intention of the humans that made
the scripts, so it's always advisable to manually check all generated
files to make sure everything is declared as it should.

Take note the program assumes this script exists in some subfolder
to the folder where `skyrimPlatform.ts` is found, otherwise you'll get
"Cannot find module..." type of errors.

If you want to have this script in some other place, just change the
relative path of each `import`.
*/

import * as sp from "../skyrimPlatform"
import { Form } from "../skyrimPlatform"

/** Common functionality, shared by JArray, JMap, JFormMap, JIntMap */
const sn = (sp as any).JValue

/** Most call entries made to JC will be logged. Heavy traffic, by default is disabled.
    Not thread safe for multiple users (though harmless). */
export const enableAPILog = (arg0: boolean): void => sn.enableAPILog(arg0)

/** --- Lifetime management functionality.
    Read this https://github.com/ryobg/JContainers/wiki/Lifetime-Management before using any of lifetime management functions
    
    Retains and returns the object. */
export const retain = (object: number, tag: string = ""): number => sn.retain(object,  tag)

/** Releases the object and returns zero, so you can release and nullify with one line of code: object = JValue.release(object) */
export const release = (object: number): number => sn.release(object)

/** Just a union of retain-release calls. Releases @previousObject, retains and returns @newObject. */
export const releaseAndRetain = (previousObject: number, newObject: number, tag: string = ""): number => sn.releaseAndRetain(previousObject,  newObject,  tag)

/** Releases all objects tagged with @tag.
    Internally invokes JValue.release on each object same amount of times it has been retained. */
export const releaseObjectsWithTag = (tag: string): void => sn.releaseObjectsWithTag(tag)

/** Minimizes the time JC temporarily owns the object, returns the object.
    By using this function you help JC to delete unused objects as soon as possible.
    Has zero effect if the object is being retained or if another object contains/references it. */
export const zeroLifetime = (object: number): number => sn.zeroLifetime(object)

/** Handly for temporary objects (objects with no owners) - the pool 'locationName' owns any amount of objects, preventing their destuction, extends lifetime.
    Do not forget to clean the pool later! Typical use:
    int jTempMap = JValue.addToPool(JMap.object(), "uniquePoolName")
    int jKeys = JValue.addToPool(JMap.allKeys(someJMap), "uniquePoolName")
    and anywhere later:
    JValue.cleanPool("uniquePoolName") */
export const addToPool = (object: number, poolName: string): number => sn.addToPool(object,  poolName)
export const cleanPool = (poolName: string): void => sn.cleanPool(poolName)

/** --- Mics. functionality
    
    Returns shallow copy (won't copy child objects) */
export const shallowCopy = (object: number): number => sn.shallowCopy(object)

/** Returns deep copy */
export const deepCopy = (object: number): number => sn.deepCopy(object)

/** Tests whether given object identifier is not the null object.
    Note that many other API functions already check that too. */
export const isExists = (object: number): boolean => sn.isExists(object)

/** Returns true if the object is map, array or formmap container */
export const isArray = (object: number): boolean => sn.isArray(object)
export const isMap = (object: number): boolean => sn.isMap(object)
export const isFormMap = (object: number): boolean => sn.isFormMap(object)
export const isIntegerMap = (object: number): boolean => sn.isIntegerMap(object)

/** Returns true, if the container is empty */
export const empty = (object: number): boolean => sn.empty(object)

/** Returns amount of items in the container */
export const count = (object: number): number => sn.count(object)

/** Removes all items from the container */
export const clear = (object: number): void => sn.clear(object)

/** JSON serialization/deserialization:
    
    Creates and returns a new container object containing contents of JSON file */
export const readFromFile = (filePath: string): number => sn.readFromFile(filePath)

/** Parses JSON files in a directory (non recursive) and returns JMap containing {filename, container-object} pairs.
    Note: by default it does not filter files by extension and will try to parse everything */
export const readFromDirectory = (directoryPath: string, extension: string = ""): number => sn.readFromDirectory(directoryPath,  extension)

/** Creates a new container object using given JSON string-prototype */
export const objectFromPrototype = (prototype: string): number => sn.objectFromPrototype(prototype)

/** Writes the object into JSON file */
export const writeToFile = (object: number, filePath: string): void => sn.writeToFile(object,  filePath)

/** Returns type of resolved value. 0 - no value, 1 - none, 2 - int, 3 - float, 4 - form, 5 - object, 6 - string */
export const solvedValueType = (object: number, path: string): number => sn.solvedValueType(object,  path)

/** Path resolving:
    
    Returns true, if it's possible to resolve given path, i.e. if it's possible to retrieve the value at the path.
    For ex. JValue.hasPath(container, ".player.health") will test whether @container structure close to this one - {'player': {'health': health_value}} */
export const hasPath = (object: number, path: string): boolean => sn.hasPath(object,  path)

/** Attempts to retrieve value at given path. If fails, returns @default value */
export const solveFlt = (object: number, path: string, defaultVal: number = 0.0): number => sn.solveFlt(object,  path,  defaultVal)
export const solveInt = (object: number, path: string, defaultVal: number = 0): number => sn.solveInt(object,  path,  defaultVal)
export const solveStr = (object: number, path: string, defaultVal: string = ""): string => sn.solveStr(object,  path,  defaultVal)
export const solveObj = (object: number, path: string, defaultVal: number = 0): number => sn.solveObj(object,  path,  defaultVal)
export const solveForm = (object: number, path: string, defaultVal: Form | null | undefined = null): Form | null | undefined => sn.solveForm(object,  path,  defaultVal)

/** Attempts to assign the value. If @createMissingKeys is False it may fail to assign - if no such path exist.
    With 'createMissingKeys=true' it creates any missing path element: solveIntSetter(map, ".keyA.keyB", 10, true) on empty JMap creates {keyA: {keyB: 10}} structure */
export const solveFltSetter = (object: number, path: string, value: number, createMissingKeys: boolean = false): boolean => sn.solveFltSetter(object,  path,  value,  createMissingKeys)
export const solveIntSetter = (object: number, path: string, value: number, createMissingKeys: boolean = false): boolean => sn.solveIntSetter(object,  path,  value,  createMissingKeys)
export const solveStrSetter = (object: number, path: string, value: string, createMissingKeys: boolean = false): boolean => sn.solveStrSetter(object,  path,  value,  createMissingKeys)
export const solveObjSetter = (object: number, path: string, value: number, createMissingKeys: boolean = false): boolean => sn.solveObjSetter(object,  path,  value,  createMissingKeys)
export const solveFormSetter = (object: number, path: string, value: Form | null | undefined, createMissingKeys: boolean = false): boolean => sn.solveFormSetter(object,  path,  value,  createMissingKeys)

/** Evaluates piece of lua code. Lua support is experimental */
export const evalLuaFlt = (object: number, luaCode: string, defaultVal: number = 0.0): number => sn.evalLuaFlt(object,  luaCode,  defaultVal)
export const evalLuaInt = (object: number, luaCode: string, defaultVal: number = 0): number => sn.evalLuaInt(object,  luaCode,  defaultVal)
export const evalLuaStr = (object: number, luaCode: string, defaultVal: string = ""): string => sn.evalLuaStr(object,  luaCode,  defaultVal)
export const evalLuaObj = (object: number, luaCode: string, defaultVal: number = 0): number => sn.evalLuaObj(object,  luaCode,  defaultVal)
export const evalLuaForm = (object: number, luaCode: string, defaultVal: Form | null | undefined = null): Form | null | undefined => sn.evalLuaForm(object,  luaCode,  defaultVal)
